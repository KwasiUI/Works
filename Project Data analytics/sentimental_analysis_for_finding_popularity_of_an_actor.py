# -*- coding: utf-8 -*-
"""sentimental analysis for finding popularity of an actor.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_TRp5ynr31koP0jzLvxCpf7wQgbXz3yL
"""



#@title Default title text
# -*- coding: utf-8 -*-


import re 
import tweepy 
from tweepy import OAuthHandler 
from textblob import TextBlob 

class TwitterClient(object): 
    ''' 
    Generic Twitter Class for sentiment analysis. 
    '''
    def __init__(self): 
        ''' 
        Class constructor or initialization method. 
        '''
        # keys and tokens from the Twitter Dev Console 
        consumer_key ='PX689sm0ALLKwTXddKGdoeIKg'
        consumer_secret =	'XK3b14aHUZIIaBmwunbSNS63xOxoYNjdk9pVbOahD9p0tsXnbY'

        access_token = '1021759410337505281-ELWfAMvjfZTQEQ5cppACjw1gEDLrcp'
        access_token_secret = 	'QQus0pgFJMItDHHOtztULNbEVbOLkrgAx5jqavnXTr5WY'

  
        # attempt authentication 
        try: 
            # create OAuthHandler object 
            self.auth = OAuthHandler(consumer_key, consumer_secret) 
            # set access token and secret 
            self.auth.set_access_token(access_token, access_token_secret) 
            # create tweepy API object to fetch tweets 
            self.api = tweepy.API(self.auth) 
        except: 
            print("Error: Authentication Failed") 
  
    def clean_tweet(self, tweet): 
        ''' 
        Utility function to clean tweet text by removing links, special characters 
        using simple regex statements. 
        '''
        return " ".join(re.sub('(@[A-Za-z0-9]+)|([^0-9A-Za-z \t]) |(\w+:\/\/\S+)' , " ", tweet).split()) 
  
    def get_tweet_sentiment(self, tweet): 
        ''' 
        Utility function to classify sentiment of passed tweet 
        using textblob's sentiment method 
        '''
        # create TextBlob object of passed tweet text 
        analysis = TextBlob(self.clean_tweet(tweet)) 
        # set sentiment 
        if analysis.sentiment.polarity > 0: 
            return 'positive'
        elif analysis.sentiment.polarity <0: 
            return 'negative'
        else: 
            return 'neutral'
  
    def get_tweets(self, query, count = 10): 
        ''' 
        Main function to fetch tweets and parse them. 
        '''
        # empty list to store parsed tweets 
        tweets = [] 
  
        try: 
            # call twitter api to fetch tweets 
            fetched_tweets = self.api.search(q = query, count = count) 
  
            # parsing tweets one by one 
            for tweet in fetched_tweets: 
                # empty dictionary to store required params of a tweet 
                parsed_tweet = {} 
  
                # saving text of tweet 
                parsed_tweet['text'] = tweet.text 
                # saving sentiment of tweet 
                parsed_tweet['sentiment'] = self.get_tweet_sentiment(tweet.text) 
  
                # appending parsed tweet to tweets list 
                if tweet.retweet_count > 0: 
                    # if tweet has retweets, ensure that it is appended only once 
                    if parsed_tweet not in tweets: 
                        tweets.append(parsed_tweet) 
                else: 
                    tweets.append(parsed_tweet) 
  
            # return parsed tweets 
            return tweets 
  
        except tweepy.TweepError as e: 
            # print error (if any) 
            print("Error : " + str(e)) 
  
def main(): 
    # creating object of TwitterClient Class 
    api = TwitterClient() 
    # calling function to get tweets 
    
    moviepositivepercentage=[]
    movienegativepercentage=[]
    movieneutralpercentage=[]
    names=[]
    moviepositive=[]
    movienegative=[]
    movieneutral=[]
    
    no_of_movies=int(input("enter no of movies"))  
    for i in range(0, no_of_movies):   
      st=input("enter keyword:")
      names.append(st)
      """
      if i==no_of_movies-1:
       print("names:",names)
      """
      
      tweets = api.get_tweets(query =st ,count=200) 
      #print(tweets)

      if tweets is not None:
        # picking positive tweets from tweets 

        
        moviepositive.append([tweet for tweet in tweets if tweet['sentiment'] == 'positive']) 
        # percentage of positive tweets 
        print("positive tweets percentage: {} %".format(100*len(moviepositive)/len(tweets)))
        moviepositivepercentage.append("{} %".format(100*len(moviepositive)/len(tweets)))
        print(moviepositive)
        
        # picking negative tweets from tweets 
        movienegative.append([tweet for tweet in tweets if tweet['sentiment'] == 'negative']) 
        print(movienegative)
        
        # percentage of negative tweets 
        movienegativepercentage.append(" {} %".format(100*len(movienegative)/len(tweets)))
        print("Negative tweets percentage: {} %".format(100*len(movienegative)/len(tweets))) 
        # percentage of neutral tweets 
        movieneutralpercentage.append("{} % \  ".format(100*(len(tweets )- len(moviepositive )- len(movienegative))/len(tweets)))
        print("Neutral tweets percentage: {} % \  ".format(100*(len(tweets )- len(moviepositive )- len(movienegative))/len(tweets)))
     
      
      print("moviepositive:",len(moviepositive))  
      print("moviepositive:",len(movienegative))  

      print(" movie got more positive tweets  ")
      #print(len(moviepositivepercentage))
      for i in range(0, len(moviepositivepercentage)): 
        
        if i==no_of_movies-1:
         #print(moviepositivepercentage[i])
         k=i
         l=i
        
         max=moviepositivepercentage[k]
         min=moviepositivepercentage[l]
         while k>0:
           if max<moviepositivepercentage[k-1]:
             max=moviepositivepercentage[k-1]
             
           
           k=k-1
         print(names[k],"got more positive tweets :",max)
           
         while l>0:
           if min>moviepositivepercentage[l-1]:
             min=moviepositivepercentage[l-1]
           l=l-1
         
         print(names[l],"got less positive tweets :",min)
        
           
          
      
  
if __name__ == "__main__": 
    # calling main function 
    main()